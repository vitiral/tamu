<div>
<!-- Generated by cxt.py from README.cxt -->

<blockquote>This document has been moved to <span><a href="https://github.com/civboot/civlua/tree/main/zoa">civlua</a></span></blockquote>

zoa is a set of standards related to serialized structured data and it&#x27;s textual representation and processing. It is part of the 
 
<h1>zoa: serialized data made easy</h1>
<blockquote>This document is written using <span><a href="https://github.com/civboot/cxt">cxt</a></span> in README.cxt</blockquote>
zoa is a set of standards related to serialized structured data and it&#x27;s textual representation and processing. It is part of the 
<span><a href="https://civboot.org">Civboot</a></span>
 project, specifically 
<span><a href="http://github.com/civboot/fngi">fngi</a></span>
.<p>
<blockquote> zoa is named after &quot;protozoa&quot;, which is itself a nod to <span><a href="https://developers.google.com/protocol-buffers">protobuf</a></span>. Yes, I&#x27;m aware protozoa are not fungi, but the name was too good.</blockquote>
zoa encompases the following technologies:
<ul><li><b>zty</b> <code>.zty</code>: specification for structured types similar to <span><a href="https://developers.google.com/protocol-buffers">protobuf</a></span></li><li><b>zoab</b> <code>.zoa</code>: a binary structured data composed of only data and array.</li><li><b>zoat</b> <code>.zoa</code>: an extensible text format for representing zoab in a human readable way. Zoat intentionally has little functionality on it&#x27;s own but allows extensibility and a standardized syntax for the different tools built on top of it.</li><li><b>zoac</b> <code>.zc</code>: a configuration lanugage built on zoat and and another langauge (i.e. <span><a href="http://github.com/civboot/fngi">fngi</a></span>), allowing execution of arbitrary (but stateless) user-defined functions.</li><li><b>zoash</b> <code>.zh</code>: a text-based shell built on zoac allowing creating of processes, mutation of files or anything else a computer user might want to do.  zoac functions are still callable to process data, but other functions are available as well perform side effects.  File extension: .zh</li></ul>
<blockquote>Yes, zoab and zoat have the same file extension. This is intentional and you will see how below!</blockquote>
Both zoab and zoat are extremely simple.<p>zoab is about the simplest possible general purpose structured data that can exist. Having only two types allows it to be compact and fast.  The use of single byte signals alows it to be trivially deserialized by even embedded system.<p>zoat is simpler than yaml but can achieve the same functionaly but with far less ambiguitity. The only thing it is missing is integer/float/literal-map/none types, which are not actually necessary for serializing or deserializing arbitrary structured data. Zoat also has massively increased functionality over yaml with features like variable storage and concatenation.<p>





 
<h2>zoat</h2>
zoat (like zoab) has only two data types: data and array. Data start at the first non-whitespace character (except for 
<code>|</code>
 or 
<code>{</code>
, which we will get to) and continue until a pipe. For example:<p>
<pre>This is a zoat string. It ends with a pipe|<br></pre>
An array is specified using curly braces and can be nested, like this: 
<pre>{ first string in array|<br>  second string in array|<br>  { nested array element 1|<br>    nested array element 2|<br>  }<br>}<br></pre>
Leading whitespace is always ignored until the first character, after which newlines are treated as spaces and special characters use c-like escapes. Here are the valid escapes in text: 
<pre>  \n          newline<br>  \t          tab<br>  \|          a literal &#x27;|&#x27; character<br>  \{          a literal &#x27;{&#x27; character<br>  \}          a literal &#x27;}&#x27; character<br>  \s<br>  \           a literal space character<br>  \xHH        hex byte of value 0xHH<br>  \&lt;newline&gt;  line continuation. When \ is used at the end of a line no<br>              space will be insert when going to the next line.<br><br>      An example,<br>      there is one space after the comma above. \<br>      \  However there are three spaces after the period since<br>      an escape was used both before and after the newline.|<br></pre>
The following are how to use commands. Commands must be specified immediately following either a pipe or curly brace:<p>
<pre>  |X          Where X is a non-whitespace character. Runs a command, some of<br>              which are defined below. Note that multiple &#x27;|&#x27; together are<br>              ignored, i.e. &#x27;|| | | ||&#x27; is the same as &#x27;|&#x27;.<br><br>  {           Starts an array. Characters following are always treated as text<br>              (never a command), but whitespace is still ignored. Example:<br>                {array item 1| array item 2}<br><br>  }           Ends an array. Characters following are always treated as text<br>              (never a command), but whitespace is still ignored. Example above.<br><br>              Note: {{}} will create an empty array inside a array. However,<br>              adding &#x27;|&#x27; does nothing. i.e. &#x27;|{| {||} |}|&#x27; is exactly the same.<br>              This allows for trailing pipes. If you&#x27;ve ever used JSON you know<br>              the pain of not being able to use trailing commas, this avoids<br>              that pain.<br><br>  | &lt;data&gt;    A set of data until the next &#x27;|&#x27;, &#x27;{&#x27; or &#x27;}&#x27;. There _must_ be<br>              whitespace (newline, tab or space) after | otherwise the character<br>              will be treated as a command. Whitespace will be ignored until the<br>              first non-whitespace character.<br><br>  |\          Starts text immediately using the escape. Example:<br>                  |\nThis text started on a new line.|<br><br>  |*          Line comment. Text is ignored until a newline.<br><br>  {*          Block comment {*nesting allowed*}, it must be closed with: *}<br>              After a closing block comment a new command can start immediately.<br>              Example:<br>                  {* comment *} |h1 header<br><br>  |&#x27;&#x27;&#x27;        Plain-text/code block. Any number of &#x27; can be used, and must be<br>              escaped with the same number of &#x27;, which ends the item (but will<br>              not execute a command. As a general rule only &#x27;|&#x27; executes<br>              commands). The raw text will ignore escapes (i.e. \n) and preserve<br>              newlines, _except_ for the first newline if it immediately follows<br>              the opening &#x27; block or the last newline if it immediately preceeds<br>              the &#x27; block. Also, the text will be de-indented by the indent at<br>              the start of the command. Example:<br>                |&#x27;&#x27;&#x27;<br>                This is some raw text.<br>                It will have no indent.<br>                I can use { | } \n etc and they are interpreted literally.<br>                I can even end with a space. &#x27;&#x27;&#x27;<br>                This is a new item, as if the previous had ended with pipe|<br><br>  |+          Concatenate (join) this item to the last item of the same type.<br>              Note that text starts immediately.<br>              Example:<br>                all one |+single item. ==&gt; all one single item.|<br>                {1| 2} |+ {3| 4}       ==&gt; {1| 2| 3| 4}<br><br>  |.          Begins the variable compiler, similar to fngi&#x27;s. When assigning<br>              variables, values are not added until referenced. Examples:<br><br>                |.foo = fngi |              |* set foo equal to &quot;fngi &quot;<br>                { I think |.foo|is great } |* { I think |fngi |is great }<br><br>              An array can be accessed by index using @&lt;index&gt;<br><br>                |.myArray @0 @3|            |* C equivalent: myArray[0][3]<br><br>              If the data is an array of two-length arrays with strings as the<br>              first item, you can access by key with &#x27;.&#x27;. Whitespace or special<br>              characters in the keys are not supported.<br><br>                |.myDict.foo.bar|<br><br>  |.+         Joins the variable to the last item. Example:<br>                { I think |.+foo|+is great } |* { I think fngi is great }<br><br>  |[0-9]      An integer (big-endian). 0x (hex), 0b (binary) and 0c (char) are<br>              supported. (see Type Specification Dyn)<br><br>  |-[0-9]     A negative integer (big-endian, see Type Specification Dyn)<br></pre>

 
<h2>zoab: structured array and byte data</h2>
The binary representation of zoa is called zoab. Like zoat it is composed of only two types: data and array. Both can only have sections of length 63, but a join bit may be used to make longer values.<p>The start of a zoab item has a single byte which specifies it&#x27;s type, join status and length. it looks like:<p>
<pre>  Bitmap      Description<br>  JTLL LLLL : J=join bit   T=type bit   L=length bits (0-63)<br></pre>
<ul><li><code>J</code> can be 1, which will cause it to be &quot;joined&quot; to the next item (which must be the same type). This allows the true length to be longer than 63 (any length is possible with multiple joins).</li><li><code>T</code> can be 0 for &quot;data&quot; or 1 for &quot;array&quot;.</li><li><code>L</code> contains a length (0-63) of the data or array.</li></ul>

 
<h2>Binary Runtime Type Selection</h2>
There is one byte that is invalid for both zoab and utf8 (and ascii): 
<code>J=1 T=0 L=0</code>
, which in binary is 
<code>1000 0000</code>
 or in hex is 0x80.<p>Instead of making this byte illegal, we will _require_ it in the 
<code>zoa(...)</code>
 function, which is intended to deserialize either zoab or zoat from user inputs, data stored in file systems or data transferred over the wire. If 0x80 is the first character then it is assumed this is zoab data. If 0x80 is 
<i>not</i>
 the first byte then it should be assumed that the file/etc is human written zoat.<p>
<blockquote> 0x80 will still be illegal for pure-zoab related functions, which expect the data to already be deserialzed.</blockquote>
0x80 will signal that the next byte &quot;steam type&quot;. The supported ones are:
<ol><li value="1">pure unstructured data with no special meaning.</li><li value="2">_mostly_ human readable data. i.e. struct fields are names, integers are in text format, etc. This is typically what should be passed to dbg logs, human readable compressed configs, etc.</li><li value="3">protozoa data, which is similar to protobuf. Fields are represented by user-assigned integers, data is in binary format, etc. The deserializer obviously needs access to a backwards-compatible reference (i.e. a struct definition) to know how to deserialize this data.</li><li value="4">log event, used for zoa&#x27;s own core logging.</li></ol>
We also reserve 
<code>J=1 T=1 L=0</code>
 to mean that the next data value is actually a pointer to more data. This allows fngi (or other languages) to use a maximum block size of 4kB while still permitting arbitrary length zoab data.<p>
<h2>Type Specification</h2>
<blockquote><b>WARNING:</b> This section is currently being worked on so is not yet polished.</blockquote>
Zoa also has a default type protocol and text specification for generating serializers and deserializers for zoab data. These are typically contained in 
<code>.zt</code>
 files.<p>Zoa types are specified in a language similar to protobufs, with a few key differences. For an overview:<p>Native types include:
<ul><li>Data, Int, Num, Time (integers: seconds, microseconds), Path (array of components)</li><li>Arr(generic)</li><li>IntMap(Int key, generic value), DataMap(Data key, generic value)</li><li>Dyn: dynamic (runtime) type</li></ul>
Users can create their own struct types with the format below. Struct fields can be positional or have an id. Default values can be provided, otherwise all arguments are required.<p>
<pre>\ Comments use &#x27;\&#x27; character<br>struct Foo [<br>  a: Int; \ positional required argument.<br>  b: Int = 0; \ positional argument with default.<br>  c: Data = ||; \ data argument with default.<br>  d:0 Int = 0; \ indexed argument with default.<br>  d:1 Arr[Int] = 0;<br>]<br></pre>
The struct protocol is:
<ul><li>The first items contains the number of positional args P.</li><li>The next P items contains the first P specified positional arguments. Any unspecified positional args must have a default value.</li><li>Indexed args can be specified in any order.</li><li>Any unspecified args must have a default.</li></ul>
Similarily, enumerated values can be defined. Enums must always specify their id. All ids from [0 - max specified] must be declared (in any order).<p>
<pre>struct Cheese [ isCheddar: Int ]<br>struct Cake [ isChocolate: Int ]<br>struct Pizza [<br>  cheese: Cheese = {<br>    isCheddar|1|<br>  };<br>  hasPeperoni: Int = 0;<br>]<br><br>enum Food [<br>  none:0; \ note: empty type, no data<br>  someNuts:3 Int; \ note: declared out of order (OK)<br>  pizza:1 Pizza;<br>  cake:2 Cake;<br>  cheeses:3 Arr[Cheese];<br>]<br></pre>
The enum protocol is:
<ul><li>The first item contains the enum variant, i.e. noaccount, user, admin</li><li>If the variant is not an <code>Arr</code> or <code>*Map</code>, the next item is the value.</li><li>else, the next N values are the data for the array.</li></ul>

 
<h2>Contributing</h2>
To build the README.md and run the tests, simply run 
<code>make</code>
.<p>When opening a PR to submit code to this repository you must include the following disclaimer in your first commit message:<p>
<pre>I &lt;author&gt; assent to license this and all future contributions to this project<br>under the dual licenses of the UNLICENSE or MIT license listed in the<br>`UNLICENSE` and `README.md` files of this repository.<br></pre>

 
<h2>LICENSING</h2>
This work is part of the 
<span><a href="https://civboot.org">Civboot</a></span>
 project and therefore primarily exists for educational purposes. Attribution to the authors and project is appreciated but not necessary.<p>Therefore this body of work is licensed using the UNLICENSE unless otherwise specified at the beginning of the source file.<p>If for any reason the UNLICENSE is not valid in your jurisdiction or project, this work can be singly or dual licensed at your discression with the MIT license below.<p>
<pre>Copyright 2022 Garrett Berg<br><br>Permission is hereby granted, free of charge, to any person obtaining a copy of<br>this software and associated documentation files (the &quot;Software&quot;), to deal in<br>the Software without restriction, including without limitation the rights to<br>use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies<br>of the Software, and to permit persons to whom the Software is furnished to do<br>so, subject to the following conditions:<br><br>The above copyright notice and this permission notice shall be included in all<br>copies or substantial portions of the Software.<br><br>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br>IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br>FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE<br>AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<br>LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<br>OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE<br>SOFTWARE.<br></pre>
</div>
